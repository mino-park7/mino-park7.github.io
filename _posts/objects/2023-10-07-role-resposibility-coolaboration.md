---
layout: "post"
title: "3. 역할, 책임, 협력"
date: "2023-10-07 17:10+0900"
category: Objects
tag: [Objects]
---

# 3. 역할, 책임, 협력

- 객체지향 패러다임의 관점에서 핵심은 **역할, 책임, 협력**
- 클래스, 상속, 지연 바인딩은 구현 픅면에 치우쳐있어 객체지향 패러다임의 본질과는 거리가 있다.
- 객체지향의 본질은 **협력하는 객체들의 공동체를 창조** 하는 것
- 협력 구성 -> 적절한 객체 찾기 -> 적절한 책임 할당; 클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 구현하는 것
- 이런 설계가 되기 전 구현을 해버리면 **변경하기 어렵고** 유연하지 못한 코드를 낳을 수 있다.

## 1. 협력

### 영화 예매 시스템 돌아보기

- 그림 3.1 참고
- 객체 지향 원칙을 따르는 애플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고 **다양한 객체들 사이에 균현 있게 분배되는 것이 일반적**
- 중요한 것은 다양한 객체들이 영화 예매라는 기능을 구현하기 위해 **메시지를 주고받으면서 상호작용**한다는 것
- 객체들의 상호작용을 **협력**, 객체가 협력에 참여하기 위해 수행하는 로직은 **책임**, 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성

### 협력

- **메세지 전송(message sending)**은 객체 사이의 협력을 위해 사용할 수 있는 **유일한 커뮤니케이션 수단**
- 객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기 때문에 (캡슐화) 오직 메시지 전송을 총해서만 자신의 요청은 전달
- 메시지를 수신한 객체는 **메서드**를 실행해 요청에 응답
  - 객체가 메시지를 처리할 방법을 *스스로* 선택한다는 점이 중요 -> 객체는 자신의 일을 스스로 처리할 수 있는 자율적인 존재
- 영화 예매 예제에서 `Screening`과 `Movie` 협력을 보면, `Screening`이 `Movie`에게 `caculateMovieFee` 메시지를 전송하여 요금 계산을 요청
  - 이렇게 위임을 하는 이유는 요금에 대해서 가장 잘 아는 객체가 `Movie`이기 때문이다
  - 만약 요금 계산을 `Screening`이 하려고 한다면, `Movie` 내부 구현에 직접 접근해야하고, 이는 변경하기 어려운 코드를 만든다
  - 또한 `Movie`의 자율성이 훼손됨
  - 결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 **캡슐화**하는 것 -> 변경에 대한 파급효과 제한 가능

### 협력이 설계를 위한 문맥을 결정한다

- 어떤 객체도 섬이 아니다
- 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 그 객체가 어떤 협력에 참여하고 있기 떄문
- 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 떄문
- 객체의 행동을 결정하는 것은 **객체가 참여하고 있는 협력**
  - 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 함
- 예제의 `Movie`가 `play` 메서드가 없는 이유가 뭘까? 우리의 예제는 예매를 위한 어플리케이션이기 때문이다

<br>

- 객체의 상태를 결정하는 것은 **행동**
- 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정됨
- `Movie`가 `fee`와 `discountPolicy`라는 인스턴스 변수를 상태의 일부로 포함하는 이유는 **요금 계산이라는 행동**을 수행하는데 필요하기 때문
- 상태는 객체가 행동하는데 필요한 정보에 의해 결정
- 행동은 협력 안에서 객체가 처리할 메시지로 결정
- 결과적으로 객체가 참여하는 협력이 객체를 구헝하는 행동과 상태 모두를 결정
- 협력은 **문맥(context)**을 제공

## 2. 책임

### 책임이란 무엇인가

- 협력이 갖춰진 이후에는 협력에 필요한 행동을 수행할 수 있는 적절한 객체를 찾아야 한다
- 이때 협력에 참여하기 위해 객체가 수행하는 행동을 **책임**이라고 부른다
- 책임이란 **객체에 의해 정의되는 응집도 있는 행위의 집합**
  - 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장, 이는 **하는 것**과 **아는것**으로 나뉜다

<br>

- 하는 것
  - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것
  - 사적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

<br>

- 그림 3.3, 객체의 책임을 CRC카드로 표현
- 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정
- 책임의 관점에서 '아는 것'과 '하는 것'이 밀접하게 연관돼 있다.
  - 객체는 자신이 맡은 책임을 수행하는 데 **필요한 정보를 알고 있을 책임**이 있음
  - 자신이 **할 수 없는 작업을 도와줄 객체**를 알고 있을 책임이 있다
- 책임은 객체지향 설계의 핵심
- 적절한 협력이 적절한 책임을 제공 -> 적절한 책임을 적할한 객체에게 할당 == 단순하고 유연할 설계
- 다시 한 번 강조 : 겍체지향 설계에서 가장 중요한 것은 **책임**, 구현 방법은 그 뒤의 일

### 책임 할당

- 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당 -> **INFORMATION EXPERT pattern**
- 객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의해야 함
- 협력 설계의 출발점 : 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것
  - 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고, 이를 객체들에게 할당하는 반복적인 과정
- 영화 예매 예제

```
1: 예매하라 -> :Screening -> 2: 가격을 계산하라 -> :Movie
```

- 예매 전문가 : Screening, 가격 전문가 : Movie, 할인 전문가 : DiscountPolicy, ...
- 객체 지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄진다.
- 이렇게 결정된 메시지가 객체의 **퍼블릭 인터페이스**를 구성
- 협력을 설계하면서 객체의 책임을 식별해 나가는 과정에서 최종적으로 얻게 되는 결과물은 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션의 목록

### 책임 주도 설계

- **책임 주도 설계 (Resposibility-Driven Design, RDD)** : 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악
  - 시스템 책임을 더 작은 책임으로 분할
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
  - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 함

### 메시지가 객체를 결정한다

- 